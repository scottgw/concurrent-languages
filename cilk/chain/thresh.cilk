/*
 * thresh: histogram thresholding
 *
 * input:
 *   matrix: the integer matrix to be thresholded
 *   nrows, ncols: the number of rows and columns
 *   percent: the percentage of cells to retain
 *
 * output:
 *   mask: a boolean matrix filled with true for cells kept
 */

#include <cilk-lib.cilkh>
#include <stdlib.h>

#include "common.cilkh"

int max_int(int a, int b) {
  return a > b ? a : b;
}

cilk void fill_histogram_index(int index, SplitState state) {
  state.histogram[index] = spawn reduce2d_with_filter(state.nrows,
      state.ncols, state.matrix_int, sum, filter_matrix, index);
  sync;
}

cilk void fill_histogram(int n, int* histogram, int nrows, int ncols,
    int** matrix) {
  SplitState state = {.histogram = histogram, .nrows = nrows,
    .ncols = ncols, .matrix_int = matrix};
  // parallel for on [0, n), calls fill_histogram_index()
  spawn split(0, n, fill_histogram_index, state);
}

cilk void scan_update_elements(int begin, int end, int* array, int size,
    Operator op) {
  int middle, count;
  if (end - begin <= size) {
    return;
  } else if (end - begin <= 2 * size) {
    array[begin + size] = op(array[begin], array[begin + size]);
  } else {
    count = (end - begin) / size;
    count /= 2;
    count += count % 2;  // to ensure it is even
    middle = begin + count * size;
    spawn scan_update_elements(begin, middle, array, size, op);
    spawn scan_update_elements(middle, end, array, size, op);
  }
}

// Ladner-Fischer
// parallel scan on [begin, end)
cilk void scan_impl(int begin, int end, int* array, int size, Operator op) {
  if (end - begin > size) {
    spawn scan_update_elements(begin, end, array, size, op); sync;
    spawn scan_impl(begin + size, end, array, 2 * size, op); sync;
    spawn scan_update_elements(begin + size, end, array, size, op); sync;
  }
}

cilk void scan(int n, int* array, Operator op) {
  spawn scan_impl(0, n, array, 1, op);
}

int binary_search(int n, int* array, int target) {
  int begin = 0, end = n;
  while (begin < end) {
    int middle = begin + (end - begin) / 2;
    if (array[middle] < target) {
      begin = middle + 1;
    } else if(array[middle] > target) {
      end = middle;
    } else {
      begin = end = middle;
    }
  }
  return end;
}

cilk void fill_mask_update_matrix(int col, SplitState state) {
  state.mask[state.row][col] =
    state.matrix_int[state.row][col] >= state.threshold;
}

cilk void fill_mask_start_cols(int row, SplitState state) {
  state.row = row;
  // parallel for on cols
  spawn split(0, state.ncols, fill_mask_update_matrix, state);
}

cilk void fill_mask(int nrows, int ncols, int** matrix, int** mask,
    int threshold) {
  SplitState state = {.nrows = nrows, .ncols = ncols, .matrix_int = matrix,
    .mask = mask, .threshold = threshold};
  // parallel for on rows
  spawn split(0, nrows, fill_mask_start_cols, state);
}

cilk void thresh(int nrows, int ncols, int** matrix, int percent,
    int** mask) {
  int nmax = 0;
  int* histogram;
  int count, threshold;

  nmax = spawn reduce2d(nrows, ncols, matrix, max_int); sync;

  histogram = (int*) malloc(sizeof(int) * (nmax + 1));

  spawn fill_histogram(nmax + 1, histogram, nrows, ncols, matrix); sync;

  count = (nrows * ncols * percent) / 100;
  count = nrows * ncols - count;  // scan starts from the beginning

  spawn scan(nmax + 1, histogram, sum); sync;

  threshold = binary_search(nmax + 1, histogram, count);

  spawn fill_mask(nrows, ncols, matrix, mask, threshold); sync;

  free(histogram);
}

