/*
 * winnow: weighted point selection
 *
 * input:
 *   matrix: an integer matrix, whose values are used as masses
 *   mask: a boolean matrix showing which points are eligible for
 *     consideration
 *   nrows, ncols: the number of rows and columns
 *   nelts: the number of points to select
 *
 * output:
 *   points: a vector of (x, y) points
 */

#include <cilk-lib.cilkh>
#include <stdlib.h>
#include <stdio.h>

typedef struct sPoint {
  int value, i, j;
} Point;

int compare(Point l, Point r) {
  if (l.value < r.value) return 1;
  if (l.value > r.value) return 0;
  if (l.i < r.i) return 1;
  if (l.i > r.i) return 0;
  return l.j < r.j;
}

typedef int (*Operator)(int, int);
typedef void* ReduceFilter;

typedef struct sReduceState {
  int extra, ncols;
  int row;
  int** matrix;
  Operator op;
  ReduceFilter filter;
} ReduceState;

typedef cilk int (*GenericReduceFunction)(int index, ReduceState state);

cilk int generic_reduce(int begin, int end, Operator op,
    GenericReduceFunction f, ReduceState state) {
  int middle = begin + (end - begin) / 2;
  int left, right, res;
  if (begin + 1 == end) {
    res = spawn f(begin, state);
    sync;
    return res;
  }
  left = spawn generic_reduce(begin, middle, op, f, state);
  right = spawn generic_reduce(middle, end, op, f, state);
  sync;
  return op(left, right);
}

cilk int reduce2d_identity_filter(int col, ReduceState state) {
  return state.matrix[state.row][col];
}

cilk int reduce2d_start_cols(int row, ReduceState state) {
  int res;
  state.row = row;
  res = spawn generic_reduce(0, state.ncols, state.op, state.filter, state);
  sync;
  return res;
}

cilk int reduce2d_with_filter(int nrows, int ncols, int** matrix,
    Operator op, GenericReduceFunction filter, int extra) {
  int res;
  ReduceState state = {.ncols = ncols, .matrix = matrix, .op = op,
    .filter = filter, .extra = extra};
  res = spawn generic_reduce(0, nrows, op, reduce2d_start_cols, state);
  sync;
  return res;
}

cilk int reduce2d(int nrows, int ncols, int** matrix, Operator op) {
  int res;
  res = spawn reduce2d_with_filter(nrows, ncols, matrix, op,
      reduce2d_identity_filter, 0);
  return res;
}

cilk int filter_matrix(int col, ReduceState state) {
  return state.matrix[state.row][col] == state.extra;
}

int sum(int a, int b) {
  return a + b;
}

typedef struct sSplitState {
  int nrows, ncols;
  int** matrix;
  int** mask;
  int row;
  Point* values;
  int* count;
  Point* points;
  int chunk;
} SplitState;

typedef cilk void (*SplitFunction)(int index, SplitState state);

cilk void split(int begin, int end, SplitFunction f, SplitState state) {
  int middle = begin + (end - begin) / 2;
  if (begin >= end) return;
  if (begin + 1 == end) {
    spawn f(begin, state);
    return;
  }
  spawn split(begin, middle, f, state);
  spawn split(middle, end, f, state);
}

cilk void fill_value(int col, SplitState state) {
  int row = state.row;
  if (state.mask[row][col] == 1) {
    state.values[*state.count].value = state.matrix[row][col];
    state.values[*state.count].i = row;
    state.values[*state.count].j = col;
    (*state.count)++;
  }
}

cilk void fill_values_start_cols(int row, SplitState state) {
  state.row = row;
  spawn split(0, state.ncols, fill_value, state);
}

cilk void fill_values(int nrows, int ncols, int** matrix, int** mask,
    Point* values) {
  int count = 0;
  SplitState state = {.nrows = nrows, .ncols = ncols, .matrix = matrix,
    .mask = mask, .values = values, .count = &count};
  spawn split(0, nrows, fill_values_start_cols, state);
  sync;
}

typedef int (*CompareFunction)(Point l, Point r);

void swap(Point* values, int i, int j) {
  Point p = values[i];
  values[i] = values[j];
  values[j] = p;
}

cilk void sort_impl(int start, int end, Point* values,
    CompareFunction is_less, int depth) {
  int pivot_index;
  Point pivot;
  int spot;
  int i;

  if (start >= end || start + 1 == end) return;
  pivot_index = (start + end) / 2;
  pivot = values[pivot_index];
  swap(values, pivot_index, end - 1);
  spot = start;
  for (i = start; i < end; i++) {
    if (is_less(values[i], pivot)) {
      swap(values, i, spot);
      spot++;
    }
  }
  swap(values, spot, end - 1);
  pivot_index = spot;

  spawn sort_impl(start, pivot_index, values, is_less, depth + 1);
  spawn sort_impl(pivot_index + 1, end, values, is_less, depth + 1);
}

cilk void sort(int n, Point* values, CompareFunction is_less) {
  spawn sort_impl(0, n, values, is_less, 0);
}

cilk void fill_point(int i, SplitState state) {
  int index = i * state.chunk;
  state.points[i] = state.values[index];
}

cilk void fill_points(int n, Point* points, Point* values, int chunk) {
  SplitState state = { .points = points, .values = values, .chunk = chunk};
  spawn split(0, n, fill_point, state);
}

cilk void winnow(int nrows, int ncols, int** matrix, int** mask, int nelts,
    Point* points) {
  int n = 0, chunk;
  Point* values;

  n = spawn reduce2d(nrows, ncols, mask, sum);

  values = (Point* ) malloc(sizeof(Point) * n);

  spawn fill_values(nrows, ncols, matrix, mask, values);

  spawn sort(n, values, compare);
  sync;

  chunk = n / nelts;

  spawn fill_points(nelts, points, values, chunk);
}

int** read_matrix(int nrows, int ncols) {
  int i, j;
  int** matrix = (int **) malloc(sizeof(int *) * nrows);
  for (i =  0; i < nrows; i++) {
    matrix[i] = (int *) malloc(sizeof(int) * ncols);
    for (j = 0; j < ncols; j++) {
      scanf("%d", &matrix[i][j]);
    }
  }
  return matrix;
}

void free_matrix(int nrows, int** matrix) {
  int i;
  for (i = 0; i < nrows; i++) {
    free(matrix[i]);
  }
  free(matrix);
}

cilk int main(int argc, char *argv[]) {
  int nrows, ncols, nelts, i;
  int** matrix;
  int** mask;
  Point* points;

  scanf("%d%d", &nrows, &ncols);

  matrix = read_matrix(nrows, ncols);
  mask = read_matrix(nrows, ncols);

  scanf("%d", &nelts);

  points = (Point* ) malloc(sizeof(Point) * nelts);

  spawn winnow(nrows, ncols, matrix, mask, nelts, points);
  sync;

  printf("%d\n", nelts);
  for (i = 0; i < nelts; i++) {
    printf("%d %d\n", points[i].i, points[i].j);
  }
  printf("\n");

  free_matrix(nrows, matrix);
  free_matrix(nrows, mask);
  free(points);

  return 0;
}
