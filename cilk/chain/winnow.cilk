/*
 * winnow: weighted point selection
 *
 * input:
 *   matrix: an integer matrix, whose values are used as masses
 *   mask: a boolean matrix showing which points are eligible for
 *     consideration
 *   nrows, ncols: the number of rows and columns
 *   nelts: the number of points to select
 *
 * output:
 *   points: a vector of (x, y) points
 */

#include <cilk-lib.cilkh>
#include <stdlib.h>
#include <stdio.h>

#include "common.cilkh"

int compare(Point l, Point r) {
  if (l.value < r.value) return 1;
  if (l.value > r.value) return 0;
  if (l.i < r.i) return 1;
  if (l.i > r.i) return 0;
  return l.j < r.j;
}

int sum(int a, int b);

cilk void split(int begin, int end, SplitFunction f, SplitState state);

cilk void fill_value(int col, SplitState state) {
  int row = state.row;
  if (state.mask[row][col] == 1) {
    state.values[*state.count].value = state.matrix_int[row][col];
    state.values[*state.count].i = row;
    state.values[*state.count].j = col;
    (*state.count)++;
  }
}

cilk void fill_values_start_cols(int row, SplitState state) {
  state.row = row;
  spawn split(0, state.ncols, fill_value, state);
}

cilk void fill_values(int nrows, int ncols, int** matrix, int** mask,
    Point* values) {
  int count = 0;
  SplitState state = {.nrows = nrows, .ncols = ncols, .matrix_int = matrix,
    .mask = mask, .values = values, .count = &count};
  spawn split(0, nrows, fill_values_start_cols, state);
  sync;
}

typedef int (*CompareFunction)(Point l, Point r);

void swap(Point* values, int i, int j) {
  Point p = values[i];
  values[i] = values[j];
  values[j] = p;
}

cilk void sort_impl(int start, int end, Point* values,
    CompareFunction is_less, int depth) {
  int pivot_index;
  Point pivot;
  int spot;
  int i;

  if (start >= end || start + 1 == end) return;
  pivot_index = (start + end) / 2;
  pivot = values[pivot_index];
  swap(values, pivot_index, end - 1);
  spot = start;
  for (i = start; i < end; i++) {
    if (is_less(values[i], pivot)) {
      swap(values, i, spot);
      spot++;
    }
  }
  swap(values, spot, end - 1);
  pivot_index = spot;

  spawn sort_impl(start, pivot_index, values, is_less, depth + 1);
  spawn sort_impl(pivot_index + 1, end, values, is_less, depth + 1);
}

cilk void sort(int n, Point* values, CompareFunction is_less) {
  spawn sort_impl(0, n, values, is_less, 0);
}

cilk void fill_point(int i, SplitState state) {
  int index = i * state.chunk;
  state.points[i] = state.values[index];
}

cilk void fill_points(int n, Point* points, Point* values, int chunk) {
  SplitState state = { .points = points, .values = values, .chunk = chunk};
  spawn split(0, n, fill_point, state);
}

cilk void winnow(int nrows, int ncols, int** matrix, int** mask, int nelts,
    Point* points) {
  int n = 0, chunk;
  Point* values;

  n = spawn reduce2d(nrows, ncols, mask, sum);

  values = (Point* ) malloc(sizeof(Point) * n);

  spawn fill_values(nrows, ncols, matrix, mask, values);

  spawn sort(n, values, compare);
  sync;

  chunk = n / nelts;

  spawn fill_points(nelts, points, values, chunk);
}

