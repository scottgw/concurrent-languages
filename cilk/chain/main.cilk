/*
 * chain: chain all problems
 *
 * input:
 *   nelts: the number of elements
 *   randmat_seed: random number generator of cells to retain
 *   thresh_percent: percentage of cells to retain
 *   winnow_nelts: the number of points to select
 *
 * output:
 *   result: a real vector, whose values are the result of the final product
 */
#include <cilk-lib.cilkh>
#include <stdlib.h>
#include <stdio.h>

#include "common.cilkh"

cilk void split(int begin, int end, SplitFunction f, SplitState state) {
  int middle = begin + (end - begin) / 2;

  if (begin >= end) return;
  if (begin + 1 == end) {
    spawn f(begin, state);
    return;
  }
  spawn split(begin, middle, f, state);
  spawn split(middle, end, f, state);
}

cilk int reduce2d_identity_filter(int col, ReduceState state) {
  return state.matrix[state.row][col];
}

cilk int generic_reduce(int begin, int end, Operator op,
    GenericReduceFunction f, ReduceState state) {
  int middle = begin + (end - begin) / 2;
  int left, right, res;
  if (begin + 1 == end) {
    res = spawn f(begin, state);
    sync;
    return res;
  }
  left = spawn generic_reduce(begin, middle, op, f, state);
  right = spawn generic_reduce(middle, end, op, f, state);
  sync;
  return op(left, right);
}

cilk int reduce2d_start_cols(int row, ReduceState state) {
  int res;
  state.row = row;
  res = spawn generic_reduce(0, state.ncols, state.op, state.filter, state);
  sync;
  return res;
}

cilk int reduce2d_with_filter(int nrows, int ncols, int** matrix,
    Operator op, GenericReduceFunction filter, int extra) {
  int res;
  ReduceState state = {.ncols = ncols, .matrix = matrix, .op = op,
    .filter = filter, .extra = extra};
  res = spawn generic_reduce(0, nrows, op, reduce2d_start_cols, state);
  sync;
  return res;
}

cilk int reduce2d(int nrows, int ncols, int** matrix, Operator op) {
  int res;
  res = spawn reduce2d_with_filter(nrows, ncols, matrix, op,
      reduce2d_identity_filter, 0);
  return res;
}

cilk int filter_matrix(int col, ReduceState state) {
  return state.matrix[state.row][col] == state.extra;
}

int sum(int a, int b) {
  return a + b;
}

int** create_matrix_int(int nrows, int ncols) {
  int** matrix = (int **) malloc(sizeof(int *) * nrows);
  int i;
  for (i =  0; i < nrows; i++) {
    matrix[i] = (int *) malloc(sizeof(int) * ncols);
  }
  return matrix;
}

double** create_matrix_double(int nrows, int ncols) {
  double** matrix = (double**) malloc(sizeof(double*) * nrows);
  int i;
  for (i =  0; i < nrows; i++) {
    matrix[i] = (double*) malloc(sizeof(double) * ncols);
  }
  return matrix;
}

void free_matrix_int(int nrows, int** matrix) {
  int i;
  for (i = 0; i < nrows; i++) {
    free(matrix[i]);
  }
  free(matrix);
}

void free_matrix_double(int nrows, double** matrix) {
  int i;
  for (i = 0; i < nrows; i++) {
    free(matrix[i]);
  }
  free(matrix);
}

cilk void randmat(int, int, int, int**);
cilk void thresh(int, int, int**, int, int**);
cilk void winnow(int, int, int**, int**, int, Point*);
cilk void outer(int, Point*, double**, double*);
cilk void product(int, double**, double*, double*);

cilk int main() {
  int nelts, randmat_seed, thresh_percent, winnow_nelts, i;
  int** randmat_matrix, **thresh_mask;
  Point* winnow_points;
  double** outer_matrix;
  double* outer_vector, *product_result;

  setbuf(stdout, NULL); // TODO REMOVE !!!!

  scanf("%d%d%d%d", &nelts, &randmat_seed, &thresh_percent, &winnow_nelts);

  randmat_matrix = create_matrix_int(nelts, nelts);
  thresh_mask = create_matrix_int(nelts, nelts);
  winnow_points = (Point*) malloc(sizeof(Point) * winnow_nelts);
  outer_matrix = create_matrix_double(winnow_nelts, winnow_nelts);
  outer_vector = (double*) malloc(sizeof(double) * winnow_nelts);
  product_result = (double*) malloc(sizeof(double) * winnow_nelts);

  spawn randmat(nelts, nelts, randmat_seed, randmat_matrix);
  spawn thresh(nelts, nelts, randmat_matrix, thresh_percent, thresh_mask);
  spawn winnow(nelts, nelts, randmat_matrix, thresh_mask, winnow_nelts,
      winnow_points);
  spawn outer(winnow_nelts, winnow_points, outer_matrix, outer_vector);
  spawn product(winnow_nelts, outer_matrix, outer_vector, product_result);

  printf("%d\n", winnow_nelts);
  for (i = 0; i < winnow_nelts; i++) {
    printf("%g ", product_result[i]);
  }
  printf("\n");

  free_matrix_int(nelts, randmat_matrix);
  free_matrix_int(nelts, thresh_mask);
  free(winnow_points);
  free_matrix_double(winnow_nelts, outer_matrix);
  free(outer_vector);
  free(product_result);

  return 0;
}

