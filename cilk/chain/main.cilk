/*
 * chain: chain all problems
 *
 * input:
 *   nelts: the number of elements
 *   randmat_seed: random number generator of cells to retain
 *   thresh_percent: percentage of cells to retain
 *   winnow_nelts: the number of points to select
 *
 * output:
 *   result: a real vector, whose values are the result of the final product
 */

#include <cilk-lib.cilkh>
#include <stdlib.h>
#include <stdio.h>

typedef cilk void (*Function)(int, int, int**);

cilk void split(int begin, int end, int extra, int** matrix, Function f) {
  int middle = begin + (end - begin) / 2;
  if (begin >= end) return;
  if (begin + 1 == end) {
    spawn f(begin, extra, matrix);
    return;
  }
  spawn split(begin, middle, extra, matrix, f);
  spawn split(middle, end, extra, matrix, f);
}

typedef int (*Operator)(int, int);
typedef void* ReduceFilter;

typedef struct sReduceState {
  int extra, ncols;
  int row;
  int** matrix;
  Operator op;
  ReduceFilter filter;
} ReduceState;

typedef cilk int (*GenericReduceFunction)(int index, ReduceState state);

cilk int reduce2d_identity_filter(int col, ReduceState state) {
  return state.matrix[state.row][col];
}

cilk int generic_reduce(int begin, int end, Operator op,
    GenericReduceFunction f, ReduceState state) {
  int middle = begin + (end - begin) / 2;
  int left, right, res;
  if (begin + 1 == end) {
    res = spawn f(begin, state);
    sync;
    return res;
  }
  left = spawn generic_reduce(begin, middle, op, f, state);
  right = spawn generic_reduce(middle, end, op, f, state);
  sync;
  return op(left, right);
}

cilk int reduce2d_start_cols(int row, ReduceState state) {
  int res;
  state.row = row;
  res = spawn generic_reduce(0, state.ncols, state.op, state.filter, state);
  sync;
  return res;
}

cilk int reduce2d_with_filter(int nrows, int ncols, int** matrix,
    Operator op, GenericReduceFunction filter, int extra) {
  int res;
  ReduceState state = {.ncols = ncols, .matrix = matrix, .op = op,
    .filter = filter, .extra = extra};
  res = spawn generic_reduce(0, nrows, op, reduce2d_start_cols, state);
  sync;
  return res;
}

cilk int reduce2d(int nrows, int ncols, int** matrix, Operator op) {
  int res;
  res = spawn reduce2d_with_filter(nrows, ncols, matrix, op,
      reduce2d_identity_filter, 0);
  return res;
}

cilk int filter_matrix(int col, ReduceState state) {
  return state.matrix[state.row][col] == state.extra;
}

int sum(int a, int b) {
  return a + b;
}

int** create_matrix_int(int nrows, int ncols) {
  int** matrix = (int **) malloc(sizeof(int *) * nrows);
  int i;
  for (i =  0; i < nrows; i++) {
    matrix[i] = (int *) malloc(sizeof(int) * ncols);
  }
  return matrix;
}

double** create_matrix_double(int nrows, int ncols) {
  double** matrix = (double**) malloc(sizeof(double*) * nrows);
  int i;
  for (i =  0; i < nrows; i++) {
    matrix[i] = (double*) malloc(sizeof(double) * ncols);
  }
  return matrix;
}

void free_matrix_int(int nrows, int** matrix) {
  int i;
  for (i = 0; i < nrows; i++) {
    free(matrix[i]);
  }
  free(matrix);
}

void free_matrix_double(int nrows, double** matrix) {
  int i;
  for (i = 0; i < nrows; i++) {
    free(matrix[i]);
  }
  free(matrix);
}

typedef struct sPoint {
  int i, j;
} Point;

cilk int main() {
  //int nelts, randmat_seed, thresh_percent, winnow_nelts;
  return 0;
}

